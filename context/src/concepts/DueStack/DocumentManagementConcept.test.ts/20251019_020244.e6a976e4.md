---
timestamp: 'Sun Oct 19 2025 02:02:44 GMT-0400 (Eastern Daylight Time)'
content_id: e6a976e428d9e74c1959b1c1c3ba11c67837dd03b9d023787af40dc2bbb92cc6
---

# file: src/concepts/DueStack/DocumentManagementConcept.test.ts

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import DocumentManagementConcept from "./DocumentManagementConcept.ts";

const userA = "user:Alice" as ID;
const courseX = "course:CS101" as ID;
const courseY = "course:CS102" as ID;

Deno.test("DocumentManagement: Principle - User uploads document, metadata is stored, and content is retrievable", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);

  try {
    const rawContent = "This is the raw content of the syllabus PDF.";
    const fileName = "syllabus.pdf";
    const fileType = "application/pdf";

    // 1. User uploads a document
    const uploadResult = await docConcept.uploadDocument({
      course: courseX,
      fileName,
      fileType,
      rawFileContent: rawContent,
      uploader: userA,
    });
    assertNotEquals("error" in uploadResult, true, "Upload should not fail.");
    const { document, processedTextContent, contentUrl } = uploadResult as {
      document: ID;
      processedTextContent: string;
      contentUrl: string;
    };
    assertExists(document);
    assertExists(processedTextContent);
    assertExists(contentUrl);
    assertEquals(
      processedTextContent.startsWith("[Extracted Text from syllabus.pdf]:"),
      true,
      "Processed text should be simulated.",
    );
    assertEquals(
      contentUrl.startsWith("https://mock-storage.com/"),
      true,
      "Content URL should be simulated.",
    );

    // Verify document metadata is stored
    const storedDoc = await docConcept._getDocumentById({ document });
    assertExists(storedDoc);
    assertEquals(storedDoc.fileName, fileName);
    assertEquals(storedDoc.fileType, fileType);
    assertEquals(storedDoc.uploader, userA);
    assertEquals(storedDoc.course, courseX);
    assertEquals(storedDoc.contentUrl, contentUrl);
    assertEquals(storedDoc.processedTextContent, processedTextContent);

    // 2. Content is retrievable
    const getContentResult = await docConcept.getDocumentContent({ document });
    assertNotEquals(
      "error" in getContentResult,
      true,
      "Getting content should not fail.",
    );
    const { processedTextContent: retrievedContent } = getContentResult as {
      processedTextContent: string;
    };
    assertEquals(retrievedContent, processedTextContent);

    // 3. Document metadata can be updated
    const updateMetadataResult = await docConcept.updateDocumentMetadata({
      document,
      newFileName: "new_syllabus.pdf",
      newFileType: "text/plain",
    });
    assertEquals(
      "error" in updateMetadataResult,
      false,
      "Updating metadata should succeed.",
    );
    const updatedDoc = await docConcept._getDocumentById({ document });
    assertExists(updatedDoc);
    assertEquals(updatedDoc.fileName, "new_syllabus.pdf");
    assertEquals(updatedDoc.fileType, "text/plain");

    // 4. Document can be deleted
    const deleteResult = await docConcept.deleteDocument({ document });
    assertEquals("error" in deleteResult, false, "Deletion should succeed.");
    const deletedDoc = await docConcept._getDocumentById({ document });
    assertEquals(deletedDoc, null, "Document should no longer exist.");
  } finally {
    await client.close();
  }
});

Deno.test("DocumentManagement: uploadDocument requires rawFileContent to be non-empty", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);

  try {
    const result = await docConcept.uploadDocument({
      course: courseX,
      fileName: "empty.txt",
      fileType: "text/plain",
      rawFileContent: "",
      uploader: userA,
    });
    assertEquals("error" in result, true, "Upload with empty content should fail.");
    assertEquals(
      (result as { error: string }).error,
      "rawFileContent cannot be empty.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("DocumentManagement: updateDocumentMetadata fails for non-existent document", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);
  const nonExistentDocId = "doc:fake" as ID;

  try {
    const result = await docConcept.updateDocumentMetadata({
      document: nonExistentDocId,
      newFileName: "fake.txt",
      newFileType: "text/plain",
    });
    assertEquals(
      "error" in result,
      true,
      "Updating metadata for non-existent document should fail.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("DocumentManagement: getDocumentContent fails for non-existent document", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);
  const nonExistentDocId = "doc:fake" as ID;

  try {
    const result = await docConcept.getDocumentContent({
      document: nonExistentDocId,
    });
    assertEquals(
      "error" in result,
      true,
      "Getting content for non-existent document should fail.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("DocumentManagement: deleteDocument fails for non-existent document", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);
  const nonExistentDocId = "doc:fake" as ID;

  try {
    const result = await docConcept.deleteDocument({
      document: nonExistentDocId,
    });
    assertEquals(
      "error" in result,
      true,
      "Deleting non-existent document should fail.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("DocumentManagement: Multiple documents for different users/courses", async () => {
  const [db, client] = await testDb();
  const docConcept = new DocumentManagementConcept(db);

  const userB = "user:Bob" as ID;

  try {
    const doc1Result = await docConcept.uploadDocument({
      course: courseX,
      fileName: "doc1.txt",
      fileType: "text/plain",
      rawFileContent: "Content for doc1.",
      uploader: userA,
    });
    const { document: doc1 } = doc1Result as { document: ID };

    const doc2Result = await docConcept.uploadDocument({
      course: courseY,
      fileName: "doc2.pdf",
      fileType: "application/pdf",
      rawFileContent: "Content for doc2.",
      uploader: userA,
    });
    const { document: doc2 } = doc2Result as { document: ID };

    const doc3Result = await docConcept.uploadDocument({
      course: courseX,
      fileName: "doc3.jpg",
      fileType: "image/jpeg",
      rawFileContent: "Content for doc3.",
      uploader: userB,
    });
    const { document: doc3 } = doc3Result as { document: ID };

    const docsUserA = await docConcept._getDocumentsByUser({ uploader: userA });
    assertEquals(docsUserA.length, 2, "UserA should have 2 documents.");
    assertExists(docsUserA.find((d) => d._id === doc1));
    assertExists(docsUserA.find((d) => d._id === doc2));

    const docsUserB = await docConcept._getDocumentsByUser({ uploader: userB });
    assertEquals(docsUserB.length, 1, "UserB should have 1 document.");
    assertExists(docsUserB.find((d) => d._id === doc3));

    const docsCourseX = await docConcept._getDocumentsByCourse({ course: courseX });
    assertEquals(docsCourseX.length, 2, "CourseX should have 2 documents.");
    assertExists(docsCourseX.find((d) => d._id === doc1));
    assertExists(docsCourseX.find((d) => d._id === doc3));

    const docsCourseY = await docConcept._getDocumentsByCourse({ course: courseY });
    assertEquals(docsCourseY.length, 1, "CourseY should have 1 document.");
    assertExists(docsCourseY.find((d) => d._id === doc2));
  } finally {
    await client.close();
  }
});

```

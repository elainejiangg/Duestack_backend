---
timestamp: 'Sat Oct 18 2025 20:21:32 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251018_202132.4797fb07.md]]'
content_id: 5a9d5a58de1d5d2aba0e06ebfca796867e79abde610239d2b1ac08e40a99cd78
---

# response:

In concept specifications, **generic types** (also referred to as **type parameters**) are placeholders for types of objects that are created and managed *externally* to the concept being defined.

Here's a breakdown of what they are and why they are crucial:

1. **External Origin**: Generic types represent entities (like `User`, `Item`, `Target`) that originate or are defined by *other* parts of the application or *other* concepts. The concept currently being specified doesn't "own" or define the full nature of these types.

2. **Polymorphic Treatment (No Assumed Properties)**: The most critical characteristic is that a concept must treat these generic types **completely polymorphically**. This means the concept cannot assume anything about their internal structure, properties, or interpretation beyond their identity. For example, a `Comment` concept that takes `[User, Target]` cannot assume a `User` has a "name" field or that a `Target` has "content." It only knows `User` and `Target` as abstract identifiers.

3. **Identity-Based Comparison**: The only operation a concept can reliably perform on generic types is to compare them to determine if two instances represent the same object (i.e., if their identifiers/references are identical).

4. **Enabling Independence and Reuse**:
   * **Independence**: By not knowing the specifics of `User` or `Target`, a concept remains decoupled from other parts of the system. This prevents direct dependencies and makes concepts "independently understandable."
   * **Reuse**: This polymorphism allows a single concept to be highly reusable across different applications or within the same application for different roles. For example:
     * An `Upvote` concept can upvote any `Item`, whether that `Item` is a `Post`, a `Comment`, or a `Product`.
     * A `Comment` concept can be used to comment on arbitrary `Target` types (e.g., a blog post, a video, another comment).
       The concept is described as applying to "arbitrary targets, defined only by their identity."

5. **Composition via Syncs**: When concepts are brought together in an application, these generic type parameters are instantiated with concrete types (often IDs generated by other concepts). The actual relationships and interactions between these concrete types (and thus across concepts) are managed externally through `synchronizations` (syncs), not by direct reference within the concepts themselves.

**Example from the documentation:**

For the `Comment [User, Target]` concept:

* `User` is a generic type that will represent the authors of comments. In a specific application, it might be the `ID` of a user generated by a `UserAuthentication` concept.
* `Target` is a generic type that will represent what is being commented on. In a specific application, it might be the `ID` of a `Post` from a `Post` concept, or an `Article` from an `Article` concept.

The `Comment` concept itself doesn't need to know *what* a `User` or `Target` *is* beyond their unique identifier; it only needs to know that a comment has an author (of type `User`) and is associated with something (of type `Target`).

---
timestamp: 'Sun Oct 19 2025 20:38:14 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251019_203814.7c2425a8.md]]'
content_id: 4fc20f5f1929389a7d6134ace8229af766f1171efaea4acb4f500ff2d4efe11b
---

# Structure of a concept specification

A concept is specified with the following structure:

* **concept**: a descriptive name balancing generality of use and appropriate specificity
* **purpose**: the reason for why this concept exists, and what it enables
* **principle**: a motivating scenario that establishes how the concept achieves its purpose in the typical case
* **state**: a description of the state stored by the concept, which comprises what the executing concept remembers about the actions that have occurred
* **actions**: a set of actions specified in traditional pre/post style that correspond to steps that are taken in the execution of the concept.

## Concept name and type parameters

The concept section gives the *name* of the concept, and a list of *type* *parameters*. These type parameters are for the types of objects that are created externally to the concept, and must be treated completely polymorphically by the concept (that is, the concept can't assume that they have any properties at all and can only be compared to determine if two instances of the type are the same identifier/reference and thus represent the same object).

For example, this concept section

**concept** Comment \[User, Target]

gives the name *Comment* to the concept, and says that its state and actions will refer to values of two externally defined generic types, *User* which will turn out be used to reference the authors of comments, and *Target* which will turn out be used to reference the target of each comment. Depending on the context in which the concept is used, the values of type *User* will likely be the identities of registered users generated by a user authentication or user profile concept; the values of type *Target* may be the identities of posts or comments or whatever is being commented on.

## Concept purpose

The *purpose* defines in a brief phrase or sentence what the motivation is for the concept's existence, and the need that it serves. Often the purpose will be obvious, such as the purpose of a *Comment* concept:

**purpose** associate some text with another artifact (usually itself textual) that remarks on, augments or explains it

Sometimes the purpose may seem obvious but will actually be more subtle than many users realize at first. For example, here is the purpose of the *Trash* concept:

**purpose** support deletion of items with possibility of restoring

As introduced by Apple for the Lisa in the 1980s and now widely used in many apps, the purpose of the trash is not to support deletion of items but rather to allow *undeletion*,  since the whole point of the trash is that a deleted item can be restored.

Sometimes the purpose is subtle. For example, here is the purpose of the *ParagraphStyle* concept (as found in many document processing tools, such as Microsoft Word):

**purpose** make consistent changes to formatting of a document easy

This purpose is fulfilled by maintaining an association between paragraphs and their styles in the state, so that a change to a paragraph style causes an update to the format of every associated paragraph. You might have thought that the purpose is to allow you to apply a predefined format to a paragraph, and indeed this purpose is fulfilled too. But it is not the defining purpose, because that simpler purpose is fulfilled by a more basic concept that just holds a set of styles with their formats and does not maintain any association between paragraphs and styles.

A good purpose should satisfy these criteria:

* **Need-focused**. The purpose should be stated in terms of the needs of the user. For example, the purpose of the *Upvote* concept should not be to “express your approval of an item” since that has no tangible benefit; a better purpose might be to “use crowd-sourced approval to rank items.”
* **Specific**. The purpose should be specific to the design of the concept at hand. For example, even though an *Autocomplete* concept in Gmail may make the app more attractive to consumers, it wouldn’t be useful to say that its purpose is to “increase the Gmail user base” since presumably all concepts have that goal. A better purpose might be “to save the user typing effort.”
* **Evaluable**. A purpose should be a yardstick against which to measure a concept design. For example, a good purpose for the *Trash* concept is “to allow undeletion.” The apparently similar purpose “to prevent accidental deletion” is not good because evaluating the concept design against that goal would require all kinds of assumptions about user behavior.

## Concept principle

The *operational principle* (or *principle*) is an archetypal scenario that explains how the concept fulfills its purpose.

A compelling way to explain how something works is to tell a story. Not any story, but a kind of defining story that shows, through a typical scenario, why the thing is useful and fulfills its purpose.

* The Minuteman Library Network, for example, offers a wonderful service. If I request a book, then when it becomes available at my local library, I get an email notifying me that it’s ready to be picked up.

Note the form this scenario takes: *if* you perform some actions, *then* some result occurs that fulfills a useful purpose. Many kinds of mechanism can be described in this way:

* If you make social security payments every month while you work, then you will receive a basic income from the government after you retire.
* If you insert a slice of bread into the toaster and press down the lever, then a few minutes later the lever will pop up and your bread will be toast.
* If you become someone’s friend and they then publish an item, you will be able to view it.

Here are some examples of principles:

* **Password**. If you register with a user name and password, and then you login with that same user name and password, you will be authenticated as the user who registered.
* **Personal access token**. If you create an access token for a resource and pass it to another user, then that user can enter the token string and obtain access, but if you revoke the token, they will not be able to obtain access after that.

Note that a principle is not always the simplest scenario. For the *PersonalAccessToken* case, for example, it's important to include what happens when the token is revoked because being able to revoke a token is essential to the concept and what distinguishes it from the *Password* concept. If you used a regular password to grant another user access to your account, for example, then having shared it, your only way of stopping them from accessing it would be to change the password, which would inconvenience you (and anyone else you shared the password with).

Another example: here is a principle for the *ParagraphStyle* concept:

**principle** after a style is defined and applied to multiple paragraphs, updating the style will cause the format of all those paragraphs to be updated in concert

A good principle should satisfy these criteria:

* **Goal focused**. The principle should demonstrate how the purpose is fulfilled. For example, since the purpose of the *Trash* concept is to allow deleted items to be restored, the principle cannot just involve a deletion without a subsequent restore.
* **Differentiating**. The principle should distinguish the functionality of the concept from other concepts, especially simpler ones. For example, the  principle of *PersonalAccessToken* must include revocation of a token since that is the motivator of its design and what distinguishes it from the simpler *Password* concept. The principle of the *ParagraphStyle* concept must include more than one paragraph being styled with a single style, since otherwise the ability to update the format of multiple paragraphs at once is not demonstrated.
* **Archetypal**. The principle should not include corner cases that are not essential to demonstrating how the concept fulfills its purpose. For example, the principle of a *RestaurantReservation* concept should include reserving a table and eventually being seated, but it does not need to include the possibility that the reservation is canceled, even though the concept will include an action to support this. The reason such cases are not needed is that the states and actions sections fully define the behavior of the concept and thus define all possible scenarios implicitly; the role of the principle is to identify the essential scenario that motivates the design and shows how the purpose is fulfilled.

## Concept state

The concept state is a data model that represents the set of possible states of the executing concept. For example, a concept for authenticating users might have a state declared like this:

```
a set of Users with
  a username String
  a password String
```

This says that the state includes a set of users and associates with each user a username and a password, each of which is a string. Mathematically, this says that there is a set of users and two relations, one called username and one called password, both from users to strings. Every value in a state is either a primitive (like a number, boolean or string) or an entity value (like a user). Entity values should be viewed as identities or references.

### Separation of concerns and different views

Although it is possible to think of a declaration such as this as defining a collection of composite objects (users with username and password fields), this view is not a completely reliable one because it does not account for the way concept states can represent different aspects of an object. For example, a separate *UserProfile* concept could have a state that includes this declaration

```
a set of Users with
  a bio String
  a thumbnail Image
```

associating a bio and thumbnail with each user. These two declarations describe different properties of users, and are best thought of as different views of a user, or as a partitioning of the data model. This kind of separation of concerns is a central feature of concept design and is not easily explained using traditional object-oriented notions that require an object to have a single global definition.

## Concept actions

When a concept executes, its observable behavior comprises an interleaved sequence of events and queries. The events are instances of *actions*, and usually mutators of the state. A concept specification always includes definitions of its actions. Queries, by contrast, are often defined implicitly by the state and do not need to be explicitly specified. See section below.

Some examples of actions:

* For a *UserAuthentication* concept: register, login, logout
* For a *RestaurantReservation* concept: reserve, cancel, seat, noShow
* For a *Trash* concept: delete, restore, empty
* For a *Labeling* concept: addLabel, removeLabel
* For a *Folder* concept: createFolder, delete, rename, move

If the state is to be initialized in a domain-specific way, actions will be needed to do that. For example, if the *RestaurantReservation* concept just uses fixed time blocks (for example, allowing any reservations between 6pm and 10pm on any day) then such an assumption can be hardwired into the behavior of the concept. But if the the *RestaurantReservation* concept only allows reservations to be made in times that have been preset by the restaurant owner, it will be necessary to include actions to setup the periods in which reservations will be allowed.

### Action arguments and results

An action can have input arguments and results. For example, for the *register* action of the *UserAuthentication* concept we might have

```
register (username: String, password: String): (user: User)
```

which says that each occurrence of the register action presents as an input a username string and a password string, and returns as an output (the identifier of) a user.

In concept specifications, all arguments and results are named, and we allow multiple results. Errors and exceptions are treated as if they were normal results. Thus to represent the possibility that the register action might fail, we could declare an overloaded version of the action that returns an error string:

```
register (username: String, password: String): (error: String)
```

As with the pattern matching syntax of functional languages like ML, a concept specification can declare multiple forms for a single action name so long as they have distinct argument/result names. For design work, error cases are not normally specified, but they are included when specifying concepts for implementation.

When actions are implemented in TypeScript code, each action is represented by a method that takes a dictionary object as input and returns a dictionary object as output. The fields of the dictionary objects are the input argument and result names.

### Empty results

Note that in the implementation, a successful execution *must* return a dictionary (but it can be empty). An empty dictionary can be used to represent successful completion, but if there is also an overloaded version of the action that returns an error, the successful case must return a dictionary that is non-empty. So this is valid

```
register (username: String, password: String): (user: User)
register (username: String, password: String): (error: String)
```

but this is not valid

```
register (username: String, password: String)
register (username: String, password: String): (error: String)
```

because the non-error case (implicitly) returns an empty dictionary. Since syncs support partial matches in which the argument name is not specified, a partial pattern that does not specify the result name will match on both cases, and it will not be possible to distinguish the successful, non-error case.

### Pre and post conditions

The detailed behavior of each action is specified in classical pre/post form. The precondition, labeled with the keyword *requires*, specifies the conditions under which execution is allowed, as a constraint on the state and the input arguments. The postcondition, labeled with the keyword *effects*, specifies the outcome (the results and the new state) as a constraint on the inputs, state before, state after and the outputs.

For example, here is a specification of a *Counter* concept:

**concept** Counter

**purpose** count the number of occurrences of something

**principle** after a series of increments, the counter reflects the number of increments that occurred

**state**
  count: Number = 0
    
**actions**
  increment ()
    **requires** true
    **effects** count := count + 1

  decrement ()
    **requires** count > 0
    **effects** count := count - 1
  
  reset ()
    **requires** true
    **effects** count := 0

Notes:

* Most of the preconditions are true: that means the action can always happen.
* The postconditions are written as assignments, but they could also be written informally. For example, the postcondition of increment might say "add one to the count". It is also possible to adopt a more declarative style and write "the count after is one more than the count before".

In general, action specifications are written informally and assume frame conditions (that any state component not mentioned is not updated).

### User and system actions

An action can be performed either by the user (or as a consequence of a user request via a synchronization), or autonomously by the system. All the actions mentioned so far as user actions, and that is the default. To mark an action as a system action, mark it with the *system* keyword like this:

**system** notifyExpiry ()
**requires** the current time is after *expiryTime* and *notified* is false
**effects** set *notified* to true

Note that the precondition allows the action to happen any time after the timer expires, but in practice the implementation should make such actions occur as soon as possible.

### Preconditions are firing conditions

The pre/post specification idiom is conventional and is the same one that is used in many specification languages. Note however that in most of those languages the precondition is an *obligation* on the caller. That means that the action *can* be executed when the precondition is false, but that the outcome will be uncertain.

In concept specs, in contrast, *preconditions are firing conditions*. This means that an action can never occur when its precondition is false. For system actions, the precondition indicates when they should occur.

## Concept queries

Queries are reads of the concept state. Explicit query specifications are often not used at the design level, but in specifications of concepts for code all queries that are likely to be needed should be specified.
For example, for a *UserProfile* concept with this state

```
a set of Users with
  a username String
  a password String
```

one could define queries to extract the username and password of a user:

**queries**
\_getUsername (user: User) : (username: String)
    **requires** user exists
    **effects** returns username of user

```
\_getPassword (user: User) : (password: String)
```

    **requires** user exists
    **effects** returns password of user

Some queries return multiple objects. For example, groups contain sets of users

```
a set of Groups with
  a users set of User
```

then a query could take a group and return the set of users in it:

**queries**
\_getUsers (group: Group) : (user: User)
    **requires** group exists
    **effects** returns set of all users in the group

Note that queries, unlike actions, can return structured objects. For example, given the definitions of users and groups above, we could define a query

```
\_getUsersWithUsernamesAndPasswords (group: Group) : (user: {username: String, password: String})
```

    **requires** group exists
    **effects** returns set of all users in the group each with its username and password

that returns a set of users, each with a username and password property.

## Concepts are not objects

A common misconception is that concepts are the same as objects in object-oriented programming. Here are the key differences:

* A concept holds in its state the set of all objects that are involved in the behavioral concern that it embodies, rather than the properties of a single object.
* The specification of a concept therefore has no constructor, and objects are allocated with actions instead.
* A concept must embody all the functionality associated with a behavioral concern, unlike objects which often depend on other objects for their functioning.
* Concepts separate concerns, unlike objects in object oriented programming which tend to aggregate all properties and methods associated with a class of object.

To illustrate these differences, consider the functionality of associating labels with items and then retrieving the items that match a given label. This functionality is used in Gmail for organizing email messages for example. In an object-oriented design, one might have an *EmailMessage* class that has an instance variable holding an array of labels; a Label *class* that has an instance variable holding the string name of the label; and a *Mailbox* class  that has an instance variable holding an array of *EmailMessage* objects.

In contrast, in concept design, we would have a single concept called *Labeling* for example whose state is a mapping from generic items to sets of labels:

**concept** Labeling \[Item]
**state**
  a set of Items with
    a labels set of Label
  a set of Labels with
    a name String
**actions**
createLabel (name: String)
  addLabel (item: Item, label: Label)
  deleteLabel (item: Item, label: Label)

Note:

* The *Labeling* concept includes in its state the entire collection of items that are labeled (the state component is in fact just a relation from items to labels)
* The *Item* type is generic, and can be instantiated at runtime with any type (such as an email message)
* Unlike in the object-oriented case, there is no conflation of concerns. This concept handles only labeling, unlike in the OO case where the *EmailMessage* class has a label instance variable and thus conflates labeling with other email message functions.
* This concept is behaviorally complete, unlike the *Label* class in the OO case, which would not be usable alone. In particular, this concept allows the addition, deletion and querying of labels; in the OO design, addition and deletion would belong to the *EmailMessage* class, and querying on a label would involve both the *Mailbox* and *EmailMessage* classes.

Despite these caveats, concepts are usually implemented as object oriented classes. There is usually just one instance of the concept at runtime that handles all the relevant objects. This instance is created by calling the constructor of the class that implements the concept.

```concept
concept UserIdentity
purpose manage the core, unique identity and basic profile information for individuals interacting with the system.
principle new user identities can be created, storing their unique email and display name.

state
a set of Users with
  a email String
  a name String

actions
createUser (email: String, name: String): (user: User) or (error: String)
  requires email is unique
  effects a new User entity is created with the given email and name, and its opaque ID is returned.

updateUserName (user: User, newName: String): Empty or (error: String)
  requires user exists
  effects updates the name for the specified User.

updateUserEmail (user: User, newEmail: String): Empty or (error: String)
  requires user exists and newEmail is unique
  effects updates the email for the specified User.
```

```concept
concept UserAuthentication [User]
purpose allow users to securely register, log in, and manage their credentials.
principle a user can register with a unique username and password, log in to establish a session, and log out to end it.

state
a set of AuthenticatedUsers with
  a user User
  a username String
  a passwordHash String
  an optional sessionID String
  an optional canvasOAuthToken String // To store Canvas connection token

actions
register (user: User, username: String, password: String): Empty or (error: String)
  requires username is unique and password meets complexity requirements
  effects creates a new AuthenticatedUser, associating the provided User ID with a username and hashed password.

login (username: String, password: String): (sessionID: String, user: User) or (error: String)
  requires username and password match an existing AuthenticatedUser
  effects generates a new sessionID for the AuthenticatedUser.

logout (sessionID: String): Empty or (error: String)
  requires sessionID is valid
  effects clears the sessionID for the associated AuthenticatedUser.

changePassword (user: User, oldPassword: String, newPassword: String): Empty or (error: String)
  requires user exists, oldPassword matches, newPassword meets complexity requirements
  effects updates the passwordHash for the specified User.

connectCanvas (user: User, canvasOAuthToken: String): Empty or (error: String)
  requires user exists and canvasOAuthToken is valid
  effects stores or updates the Canvas OAuth token for the user, enabling Canvas data fetching.

disconnectCanvas (user: User): Empty or (error: String)
  requires user exists and has an existing canvasOAuthToken
  effects clears the Canvas OAuth token for the user.
```

```concept
concept CourseManagement [User]
purpose organize and categorize academic deadlines by associating them with specific courses.
principle each user can define courses, assign unique identifiers, and manage course-specific details including an optional link to an external Canvas course.

state
a set of Courses with
  a creator User
  a courseCode String
  a title String
  an optional canvasId String

actions
createCourse (creator: User, courseCode: String, title: String): (course: Course) or (error: String)
  requires courseCode is unique for the creator
  effects creates a new Course entity with the given details, linked to the creator.

updateCourse (course: Course, newCourseCode: String, newTitle: String): Empty or (error: String)
  requires course exists and newCourseCode is unique for its creator (if changed)
  effects updates the courseCode and title of an existing course.

setCanvasId (course: Course, canvasId: String): Empty or (error: String)
  requires course exists and canvasId is unique across all courses
  effects sets or updates the external Canvas ID for the specified course.

deleteCourse (course: Course): Empty or (error: String)
  requires course exists and has no associated deadlines (this external check would be via syncs)
  effects removes the specified course entity.
```

````concept
concept DeadlineManagement [User, Course]
purpose store and manage academic deadlines, tracking their status and association with courses.
principle each deadline has a due date, title, status, and is explicitly linked to a course and the user who added it.

state
a set of Deadlines with
  a course Course
  a title String
  a due DateTime
  a source of SYLLABUS or CANVAS or WEBSITE or MANUAL or IMAGE or LLM_PARSED
  a addedBy User
  an optional status of NOT_STARTED or IN_PROGRESS or DONE

actions
createDeadline (course: Course, title: String, due: DateTime, source: SYLLABUS or CANVAS or WEBSITE or MANUAL or IMAGE or LLM_PARSED, addedBy: User): (deadline: Deadline) or (error: String)
  requires course exists (this external check would be via syncs)
  effects creates a new Deadline entity with the given details.

updateDeadline (deadline: Deadline, newTitle: String, newDue: DateTime, newSource: SYLLABUS or CANVAS or WEBSITE or MANUAL or IMAGE or LLM_PARSED): Empty or (error: String)
  requires deadline exists
  effects updates the title, due date, and source of an existing deadline.

setStatus (deadline: Deadline, status: NOT_STARTED or IN_PROGRESS or DONE): Empty or (error: String)
  requires deadline exists
  effects updates the completion status of a deadline.

deleteDeadline (deadline: Deadline): Empty or (error: String)
  requires deadline exists
  effects removes the specified deadline.
```
````

```
concept DocumentManagement [User, Course]
purpose securely store and manage various uploaded materials (e.g., syllabi, screenshots) and associate them with specific courses and users.
principle each document is uniquely identified, linked to its uploading user and associated course, and its core metadata is maintained.

state
a set of UploadedDocuments with
  a course Course
  a uploader User
  a fileName String
  a fileType String // e.g., "application/pdf", "image/png", "text/plain"
  a uploadTime DateTime
  a contentUrl String // URL where the actual file content is stored externally (e.g., GCS, S3)
  a processedTextContent String // Extracted text content from the file, suitable for LLM processing

actions
uploadDocument (course: Course, fileName: String, fileType: String, rawFileContent: String, uploader: User): (document: UploadedDocument, processedTextContent: String, contentUrl: String) or (error: String)
  requires course exists (external check via syncs) and rawFileContent is non-empty
  effects simulates storing the rawFileContent in external storage, records its contentUrl and metadata. Simulates text extraction. Returns document ID, extracted text content, and contentUrl for further processing by other concepts (via syncs).

updateDocumentMetadata (document: UploadedDocument, newFileName: String, newFileType: String): Empty or (error: String)
  requires document exists
  effects updates the fileName and fileType of an existing document's metadata.

getDocumentContent (document: UploadedDocument): (processedTextContent: String) or (error: String)
  requires document exists
  effects retrieves the stored processed text content of the specified document.

deleteDocument (document: UploadedDocument): Empty or (error: String)
  requires document exists
  effects removes the specified document's metadata from the concept state and simulates deletion of its content from external storage.
```

```concept
concept SuggestionManagement [User, Document, Course]
purpose represent extracted deadline candidates from documents, images, web pages, or Canvas; optionally AI-augmented.
principle suggestions are produced via an LLM from uploaded files, web pages, or Canvas data; users confirm suggestions before they become official deadlines.

state
a set of ParsedDeadlineSuggestions with
  a user User // The user who initiated the parsing
  an optional document Document // ID of the UploadedDocument if applicable
  an optional canvasMetadata String // Raw JSON data from Canvas
  an optional websiteUrl String
  a title String
  a due DateTime
  a source of SYLLABUS or IMAGE or WEBSITE or CANVAS
  an optional confirmed Boolean = false
  an optional confidence Number (0.0–1.0)
  an optional extractionMethod of CANVAS_JSON or LLM
  an optional provenance String // e.g., LLM model version, prompt used, file name
  an optional warnings set of String // e.g., "date ambiguous", "low confidence"

a set of ExtractionConfigs with
  a name String
  a modelVersion String
  a basePromptTemplate String
  a maxTokens Number
  a temperature Number
  a timezone String
  an optional timeout Number

actions
createExtractionConfig (name: String, modelVersion: String, basePromptTemplate: String, maxTokens: Number, temperature: Number, timezone: String, optionalTimeout: Number): (config: ExtractionConfig) or (error: String)
  requires name is unique
  effects creates a new ExtractionConfig entity for LLM processing.

parseFromCanvas(user: User, canvasData: String, config: ExtractionConfig): (suggestions: List<ParsedDeadlineSuggestion>) or (error: String)
  requires config exists and canvasData is valid JSON
  effects parses assignment JSON data, creates suggestions linked to `user`.
           sets `extractionMethod = CANVAS_JSON`, `source = CANVAS`.

llmExtractFromDocument(user: User, documentId: Document, documentContent: String, config: ExtractionConfig): (suggestions: List<ParsedDeadlineSuggestion>) or (error: String)
  requires config exists, documentId exists (external check via syncs), documentContent is text or image suitable for LLM
  effects uses LLM to extract structured suggestions from document content, creates suggestions linked to `user`.
           sets `extractionMethod = LLM`, `confidence`, `provenance` (linking to `documentId`).

llmExtractFromMultipleDocuments(user: User, documentIds: List<Document>, combinedDocumentContent: String, config: ExtractionConfig): (suggestions: List<ParsedDeadlineSuggestion>) or (error: String)
  requires config exists, combinedDocumentContent is non-empty and suitable for LLM
  effects sends combined document contents to LLM in SINGLE request to enable cross-referencing, creates suggestions linked to `user`.
           sets `extractionMethod = LLM`, `confidence`, `provenance` with multi-source attribution (using `documentIds`).

llmExtractFromWebsite(user: User, url: String, websiteContent: String, config: ExtractionConfig): (suggestions: List<ParsedDeadlineSuggestion>) or (error: String)
  requires config exists, url is reachable, websiteContent is non-empty
  effects uses LLM to parse website content into deadline suggestions, creates suggestions linked to `user`.
           sets `extractionMethod = LLM`, `provenance`, `confidence`.

refineWithFeedback(suggestion: ParsedDeadlineSuggestion, feedback: String, config: ExtractionConfig): (suggestion: ParsedDeadlineSuggestion) or (error: String)
  requires suggestion exists, feedback is non-empty, config exists
  effects re-prompts LLM using user feedback to refine fields of the suggestion.
           updates title, due, warnings, or confidence. Returns the ID of the updated suggestion.

editSuggestion(suggestion: ParsedDeadlineSuggestion, newTitle: String, newDue: DateTime): Empty or (error: String)
  requires suggestion exists, newTitle is non-empty, newDue is valid
  effects updates suggestion title and due date.
           sets `warnings` to indicate manual editing.

updateSuggestionTitle(suggestion: ParsedDeadlineSuggestion, newTitle: String): Empty or (error: String)
  requires suggestion exists and newTitle is non-empty
  effects updates suggestion title.
           sets `warnings` to indicate manual editing.

updateSuggestionDate(suggestion: ParsedDeadlineSuggestion, newDue: DateTime): Empty or (error: String)
  requires suggestion exists and newDue is valid
  effects updates suggestion due date.
           sets `warnings` to indicate manual editing.

confirm (suggestion: ParsedDeadlineSuggestion, course: Course, addedBy: User): (course: Course, title: String, due: DateTime, source: SYLLABUS or IMAGE or WEBSITE or CANVAS or LLM_PARSED, addedBy: User) or (error: String)
  requires suggestion exists, is not already confirmed, has valid title and due date, and course exists (external check via syncs)
  effects marks suggestion as confirmed, and returns the data for creating a new Deadline in `DeadlineManagement`.
```
